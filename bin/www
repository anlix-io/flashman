#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var mqtts = require('../mqtts');
var debug = require('debug')('flashman:server');
var http = require('http');

/* MQTTS */
if (!process.env.FLM_MQTT_BROKER) {
	// No external MQTT server - use internal one

	var fs = require("fs");
	var mqtts_port = 1883;
	if (process.env.FLM_MQTT_PORT) {
	  mqtts_port = process.env.FLM_MQTT_PORT;
	} else {
	  var mqttsJsonParams = {};
	  try {
	    var fileContents = fs.readFileSync('./mqtts-port.json', 'utf8');
	    mqttsJsonParams = JSON.parse(fileContents);
	  } catch (err) {
	    if (err.code === 'ENOENT') {
	      console.log('Mqtt parameter file not found! Using port default 1883');
	      mqttsJsonParams['port'] = mqtts_port;
	    } else if (err.code === 'EACCES') {
	      console.log('Cannot open mqtt parameter file! Using port default 1883');
	      mqttsJsonParams['port'] = mqtts_port;
	    } else {
	      throw err;
	    }
	  }
	  mqtts_port = mqttsJsonParams.port;
	}

	var mqtts_domain = '';
	var mqtts_options = {};
  	var mqtt_secure = false;
	if (process.env.FLM_MQTTS_DOMAIN) {
	  mqtts_domain = process.env.FLM_MQTTS_DOMAIN;
	} else {
		console.log('Domain not found for MQTTS, set FLM_MQTTS_DOMAIN!');
	}

	if(mqtts_domain != '' && process.env.FLM_ACME_FILE) {
		try {
			var acmefs = fs.readFileSync(process.env.FLM_ACME_FILE);
			var acmeJsonParams = JSON.parse(acmefs);
			var certs = acmeJsonParams.DomainsCertificate.Certs;
			var i = 0;
			while(i<certs.length && !mqtt_secure) {
				if(certs[i].Certificate.Domain == mqtts_domain) {
					var keybuff = new Buffer(certs[i].Certificate.PrivateKey, 'base64');
					var certbuff = new Buffer(certs[i].Certificate.Certificate, 'base64');
					var mqtts_options = {
					  key: keybuff.toString("ascii"),
					  cert: certbuff.toString("ascii")
					}
					mqtt_secure = true;
				}
				i++;
			}
			if(!mqtt_secure)
				console.log('No Certificate found for domain!');
		} catch (err) {
	    if (err.code === 'ENOENT') {
	      console.log('ACME file not found!');
	    } else if (err.code === 'EACCES') {
	      console.log('Cannot open acme file!');
	    } else {
	      throw err;
	    }
	  }
	} else {
		console.log('ACME file not specified!');
		if(process.env.FLM_KEY_MQTT_FILE) {
			if(process.env.FLM_CERT_MQTT_FILE) {
				try {
					var mqtts_options = {
				  	key: fs.readFileSync(process.env.FLM_KEY_MQTT_FILE),
  					cert: fs.readFileSync(process.env.FLM_CERT_MQTT_FILE)
					}
					mqtt_secure = true;
				} catch (err) {
	    		if (err.code === 'ENOENT') {
	      		console.log('MQTT KEY or CERT file not found!');
	    		} else if (err.code === 'EACCES') {
	      		console.log('Cannot open MQTT KEY or CERT file!');
	    		} else {
	      		throw err;
	    		}
	  		}
			} else {
				console.log("MQTT Certificate file not specified")
			}
		} else {
			console.log("MQTT Key file not specified")
		}
	}

	var mqtt_server;
	if(mqtt_secure) {
		console.log('Using MQTT Server with TLS (MQTTS)');
		mqtt_server = require('tls').createServer(mqtts_options, mqtts.handle);
	} else {
		console.log('Using normal MQTT (not secure)');
		mqtt_server = require('net').createServer(mqtts.handle);
	}

	mqtt_server.listen(mqtts_port, function () {
	  console.log('MQTT started and listening on port ' + mqtts_port.toString());
	})

	if (process.env.FLM_TEMPORARY_MQTT_BROKER_PORT) {
		console.log();
		var mqtt_server_tmp = require('net').createServer(mqtts.handle);
		mqtt_server_tmp.listen(process.env.FLM_TEMPORARY_MQTT_BROKER_PORT, function () {
	  		console.log('Using a TEMPORARY INSECURE MQTT server on port ' + process.env.FLM_TEMPORARY_MQTT_BROKER_PORT);
		})
	}

}

/* APP */

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '8000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
